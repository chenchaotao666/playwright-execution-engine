# Playwright æµè§ˆå™¨æ‰§è¡Œå¼•æ“æ¶æ„è®¾è®¡

## ğŸ¯ é¡¹ç›®ç›®æ ‡
åˆ›å»ºä¸€ä¸ªèƒ½å¤Ÿåœ¨æµè§ˆå™¨ç¯å¢ƒä¸­ç›´æ¥è¿è¡Œ Playwright å½•åˆ¶è„šæœ¬çš„æ‰§è¡Œå¼•æ“ï¼Œå®Œå…¨å…¼å®¹ Playwright è¯­æ³•ã€‚

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### æ ¸å¿ƒæ¨¡å—åˆ’åˆ†
```
playwright-execution-engine/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ runtime/             # è¿è¡Œæ—¶ç¯å¢ƒ
â”‚   â”‚   â”œâ”€â”€ playwright-runtime.js # Playwright è¿è¡Œæ—¶é€‚é…
â”‚   â”‚   â”œâ”€â”€ test-runner.js         # æµ‹è¯•è¿è¡Œå™¨
â”‚   â”‚   â””â”€â”€ module-loader.js       # æ¨¡å—åŠ è½½å™¨
â”‚   â”œâ”€â”€ adapters/            # API é€‚é…å±‚
â”‚   â”‚   â”œâ”€â”€ page-adapter.js     # Page API é€‚é…
â”‚   â”‚   â”œâ”€â”€ locator-adapter.js  # Locator API é€‚é…
â”‚   â”‚   â”œâ”€â”€ browser-adapter.js  # Browser API é€‚é…
â”‚   â”‚   â””â”€â”€ expect-adapter.js   # æ–­è¨€ API é€‚é…
â”‚   â”œâ”€â”€ dom/                 # DOM æ“ä½œå°è£…
â”‚   â”‚   â”œâ”€â”€ element-finder.js   # å…ƒç´ æŸ¥æ‰¾
â”‚   â”‚   â”œâ”€â”€ event-simulator.js  # äº‹ä»¶æ¨¡æ‹Ÿ
â”‚   â”‚   â””â”€â”€ wait-manager.js     # ç­‰å¾…æœºåˆ¶
â”‚   â””â”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ logger.js           # æ—¥å¿—ç³»ç»Ÿ
â”‚       â”œâ”€â”€ error-handler.js    # é”™è¯¯å¤„ç†
â”‚       â””â”€â”€ compatibility.js    # å…¼å®¹æ€§æ£€æŸ¥
â”œâ”€â”€ examples/                # ç¤ºä¾‹è„šæœ¬
â”œâ”€â”€ tests/                  # æµ‹è¯•ç”¨ä¾‹
â””â”€â”€ dist/                   # æ„å»ºè¾“å‡º
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. Playwright è¿è¡Œæ—¶é€‚é… (Playwright Runtime)

ç›´æ¥æ›¿æ¢ Playwright çš„å¯¼å…¥æ¨¡å—ï¼Œè®©è„šæœ¬å¯ä»¥åŸæ ·è¿è¡Œï¼š

```javascript
// src/runtime/playwright-runtime.js
class PlaywrightRuntime {
  constructor() {
    this.setupGlobalEnvironment();
  }

  setupGlobalEnvironment() {
    // æ¨¡æ‹Ÿ @playwright/test æ¨¡å—
    window.PlaywrightTest = {
      test: this.createTestFunction(),
      expect: this.createExpectFunction()
    };

    // åˆ›å»ºæ¨¡å—åŠ è½½å™¨
    this.setupModuleSystem();
  }

  createTestFunction() {
    return (name, testFn) => {
      return {
        name,
        fn: testFn,
        run: async () => {
          const page = new PageAdapter();
          const context = { page };
          
          try {
            await testFn(context);
            console.log(`âœ… æµ‹è¯•é€šè¿‡: ${name}`);
            return { success: true };
          } catch (error) {
            console.error(`âŒ æµ‹è¯•å¤±è´¥: ${name}`, error);
            return { success: false, error };
          }
        }
      };
    };
  }

  createExpectFunction() {
    return (target) => new ExpectAdapter(target);
  }

  // è®¾ç½®æ¨¡å—ç³»ç»Ÿï¼Œè®© import è¯­å¥æ­£å¸¸å·¥ä½œ
  setupModuleSystem() {
    // æ‹¦æˆª ES6 import
    if (typeof window.importShim === 'undefined') {
      window.importShim = {
        '@playwright/test': window.PlaywrightTest
      };
    }
  }

  // ç›´æ¥æ‰§è¡Œ Playwright è„šæœ¬
  async executeScript(scriptContent) {
    // è½¬æ¢ import è¯­å¥ä¸ºæˆ‘ä»¬çš„è¿è¡Œæ—¶
    const transformedScript = this.transformImports(scriptContent);
    
    // åœ¨æ²™ç®±ç¯å¢ƒä¸­æ‰§è¡Œ
    const testCases = await this.runInSandbox(transformedScript);
    
    // æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
    const results = [];
    for (const test of testCases) {
      const result = await test.run();
      results.push({ name: test.name, ...result });
    }
    
    return results;
  }

  transformImports(scriptContent) {
    // ç®€å•çš„å­—ç¬¦ä¸²æ›¿æ¢ï¼Œå°† import è½¬æ¢ä¸ºæˆ‘ä»¬çš„è¿è¡Œæ—¶
    return scriptContent
      .replace(/import\s*{\s*test,?\s*expect\s*}\s*from\s*['"]@playwright\/test['"];?/g, 
               'const { test, expect } = window.PlaywrightTest;')
      .replace(/import\s*{\s*expect,?\s*test\s*}\s*from\s*['"]@playwright\/test['"];?/g, 
               'const { test, expect } = window.PlaywrightTest;');
  }

  async runInSandbox(scriptContent) {
    const testCases = [];
    
    // é‡å†™ test å‡½æ•°æ¥æ”¶é›†æµ‹è¯•ç”¨ä¾‹
    const originalTest = window.PlaywrightTest.test;
    window.PlaywrightTest.test = (name, fn) => {
      const testCase = originalTest(name, fn);
      testCases.push(testCase);
      return testCase;
    };

    // æ‰§è¡Œè„šæœ¬
    const scriptFunction = new Function(scriptContent);
    scriptFunction();

    // æ¢å¤åŸå§‹ test å‡½æ•°
    window.PlaywrightTest.test = originalTest;

    return testCases;
  }
}
```

### 2. æµ‹è¯•è¿è¡Œå™¨ (Test Runner)

```javascript
// src/runtime/test-runner.js
class TestRunner {
  constructor() {
    this.runtime = new PlaywrightRuntime();
    this.logger = new Logger();
  }

  // ä»æ–‡ä»¶åŠ è½½å¹¶æ‰§è¡Œè„šæœ¬
  async loadAndRun(scriptPath) {
    try {
      const response = await fetch(scriptPath);
      const scriptContent = await response.text();
      return await this.runtime.executeScript(scriptContent);
    } catch (error) {
      this.logger.error('è„šæœ¬åŠ è½½å¤±è´¥:', error);
      throw error;
    }
  }

  // ç›´æ¥æ‰§è¡Œè„šæœ¬å­—ç¬¦ä¸²
  async runScript(scriptContent) {
    return await this.runtime.executeScript(scriptContent);
  }

  // æ‰§è¡Œå¤šä¸ªè„šæœ¬æ–‡ä»¶
  async runScripts(scriptPaths) {
    const allResults = [];
    
    for (const path of scriptPaths) {
      this.logger.info(`æ‰§è¡Œè„šæœ¬: ${path}`);
      const results = await this.loadAndRun(path);
      allResults.push({ script: path, results });
    }
    
    return allResults;
  }
}
```

### 3. Page API é€‚é…å™¨

```javascript
class PageAdapter {
  constructor() {
    this.waitManager = new WaitManager();
    this.eventSimulator = new EventSimulator();
    this.elementFinder = new ElementFinder();
  }

  // æ ¸å¿ƒå¯¼èˆª API
  async goto(url) {
    if (window.location.href !== url) {
      window.location.href = url;
      await this.waitForLoadState('domcontentloaded');
    }
  }

  url() {
    return window.location.href;
  }

  title() {
    return document.title;
  }

  // æ ¸å¿ƒäº¤äº’ API
  async click(selector, options = {}) {
    const element = await this.waitForSelector(selector);
    await this.scrollIntoViewIfNeeded(element);
    
    // è§¦å‘å®Œæ•´çš„ç‚¹å‡»äº‹ä»¶åºåˆ—
    this.eventSimulator.simulateClick(element, options);
  }

  async fill(selector, value, options = {}) {
    const element = await this.waitForSelector(selector);
    await this.scrollIntoViewIfNeeded(element);
    
    // æ¸…ç©ºå¹¶å¡«å……
    element.value = '';
    element.value = value;
    
    // è§¦å‘ç›¸å…³äº‹ä»¶
    element.dispatchEvent(new Event('input', { bubbles: true }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
  }

  async press(selector, key) {
    const element = await this.waitForSelector(selector);
    element.focus();
    
    const keyEvent = new KeyboardEvent('keydown', {
      key: key,
      code: key,
      bubbles: true
    });
    
    element.dispatchEvent(keyEvent);
  }

  // ç­‰å¾…æœºåˆ¶
  async waitForSelector(selector, options = {}) {
    const timeout = options.timeout || 30000;
    return this.waitManager.waitForElement(selector, timeout);
  }

  async waitForTimeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async waitForLoadState(state = 'load') {
    return new Promise((resolve) => {
      if (state === 'load' && document.readyState === 'complete') {
        resolve();
      } else if (state === 'domcontentloaded' && document.readyState !== 'loading') {
        resolve();
      } else {
        const handler = () => {
          if ((state === 'load' && document.readyState === 'complete') ||
              (state === 'domcontentloaded' && document.readyState !== 'loading')) {
            resolve();
          }
        };
        document.addEventListener('readystatechange', handler, { once: true });
      }
    });
  }

  // ç°ä»£å®šä½å™¨ API
  locator(selector) {
    return new LocatorAdapter(selector, this);
  }

  getByRole(role, options = {}) {
    const { name } = options;
    let selector = `[role="${role}"]`;
    
    if (name) {
      selector = `[role="${role}"][aria-label*="${name}"], [role="${role}"][aria-labelledby] *:contains("${name}")`;
    }
    
    return this.locator(selector);
  }

  getByText(text, options = {}) {
    const { exact = false } = options;
    const xpath = exact 
      ? `//\*[text()="${text}"]`
      : `//\*[contains(text(),"${text}")]`;
    
    return this.locator(\`xpath=${xpath}\`);
  }

  getByLabel(text) {
    const selector = \`label:contains("${text}") input, input[aria-labelledby]:has(~ *:contains("${text}"))\`;
    return this.locator(selector);
  }

  getByPlaceholder(text) {
    return this.locator(\`[placeholder*="${text}"]\`);
  }

  // é¡µé¢å†…å®¹è·å–
  async content() {
    return document.documentElement.outerHTML;
  }

  async evaluate(fn, ...args) {
    return fn.apply(window, args);
  }

  // è¡¨å•æ§ä»¶æ“ä½œ
  async check(selector) {
    const element = await this.waitForSelector(selector);
    if (element.type === 'checkbox' || element.type === 'radio') {
      element.checked = true;
      element.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  async uncheck(selector) {
    const element = await this.waitForSelector(selector);
    if (element.type === 'checkbox') {
      element.checked = false;
      element.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  async selectOption(selector, value) {
    const element = await this.waitForSelector(selector);
    if (element.tagName === 'SELECT') {
      element.value = value;
      element.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  // è¾…åŠ©æ–¹æ³•
  async scrollIntoViewIfNeeded(element) {
    const rect = element.getBoundingClientRect();
    if (rect.bottom < 0 || rect.top > window.innerHeight) {
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      await this.waitForTimeout(100); // ç­‰å¾…æ»šåŠ¨å®Œæˆ
    }
  }
}
```

### 4. Locator é€‚é…å™¨

```javascript
class LocatorAdapter {
  constructor(selector, page) {
    this.selector = selector;
    this.page = page;
    this.filters = [];
  }

  // é“¾å¼è¿‡æ»¤å™¨
  filter(options) {
    const newLocator = new LocatorAdapter(this.selector, this.page);
    newLocator.filters = [...this.filters, options];
    return newLocator;
  }

  first() {
    return this.nth(0);
  }

  last() {
    return this.filter({ position: 'last' });
  }

  nth(n) {
    return this.filter({ position: n });
  }

  // æ ¸å¿ƒæ“ä½œæ–¹æ³•
  async click(options = {}) {
    const element = await this.getElement();
    return this.page.click(this.buildSelector(element), options);
  }

  async fill(value, options = {}) {
    const element = await this.getElement();
    return this.page.fill(this.buildSelector(element), value, options);
  }

  async press(key) {
    const element = await this.getElement();
    return this.page.press(this.buildSelector(element), key);
  }

  // çŠ¶æ€æ£€æŸ¥
  async isVisible() {
    try {
      const element = await this.getElement();
      return element.offsetParent !== null && 
             getComputedStyle(element).visibility !== 'hidden';
    } catch {
      return false;
    }
  }

  async isEnabled() {
    try {
      const element = await this.getElement();
      return !element.disabled;
    } catch {
      return false;
    }
  }

  async isChecked() {
    try {
      const element = await this.getElement();
      return element.checked || false;
    } catch {
      return false;
    }
  }

  // å†…å®¹è·å–
  async textContent() {
    const element = await this.getElement();
    return element.textContent;
  }

  async innerText() {
    const element = await this.getElement();
    return element.innerText;
  }

  async getAttribute(name) {
    const element = await this.getElement();
    return element.getAttribute(name);
  }

  // ç­‰å¾…æ–¹æ³•
  async waitFor(options = {}) {
    const { state = 'visible', timeout = 30000 } = options;
    
    switch (state) {
      case 'visible':
        return this.waitForVisible(timeout);
      case 'hidden':
        return this.waitForHidden(timeout);
      case 'attached':
        return this.waitForAttached(timeout);
      case 'detached':
        return this.waitForDetached(timeout);
    }
  }

  async waitForVisible(timeout) {
    return this.page.waitManager.waitForCondition(
      () => this.isVisible(),
      timeout,
      \`å…ƒç´  "${this.selector}" ç­‰å¾…å¯è§è¶…æ—¶\`
    );
  }

  // å†…éƒ¨æ–¹æ³•
  async getElement() {
    const elements = document.querySelectorAll(this.selector);
    
    if (elements.length === 0) {
      throw new Error(\`æ‰¾ä¸åˆ°å…ƒç´ : ${this.selector}\`);
    }

    // åº”ç”¨è¿‡æ»¤å™¨
    let filteredElements = Array.from(elements);
    
    for (const filter of this.filters) {
      filteredElements = this.applyFilter(filteredElements, filter);
    }

    if (filteredElements.length === 0) {
      throw new Error(\`è¿‡æ»¤åæ‰¾ä¸åˆ°å…ƒç´ : ${this.selector}\`);
    }

    return filteredElements[0];
  }

  applyFilter(elements, filter) {
    if (typeof filter.position === 'number') {
      return elements[filter.position] ? [elements[filter.position]] : [];
    }
    
    if (filter.position === 'last') {
      return elements.length > 0 ? [elements[elements.length - 1]] : [];
    }

    if (filter.hasText) {
      return elements.filter(el => 
        el.textContent.includes(filter.hasText)
      );
    }

    return elements;
  }

  buildSelector(element) {
    // å¦‚æœå·²ç»æœ‰å…·ä½“å…ƒç´ ï¼Œæ„å»ºå”¯ä¸€é€‰æ‹©å™¨
    if (element.id) {
      return \`#${element.id}\`;
    }
    
    // æ„å»ºè·¯å¾„é€‰æ‹©å™¨
    const path = [];
    let current = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.className) {
        selector += '.' + current.className.split(' ').join('.');
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    return path.join(' > ');
  }
}
```

### 5. ç­‰å¾…ç®¡ç†å™¨

```javascript
class WaitManager {
  constructor() {
    this.defaultTimeout = 30000;
  }

  async waitForElement(selector, timeout = this.defaultTimeout) {
    return new Promise((resolve, reject) => {
      // ç«‹å³æ£€æŸ¥
      const existing = document.querySelector(selector);
      if (existing) return resolve(existing);

      let timeoutId;
      let observer;

      const cleanup = () => {
        if (timeoutId) clearTimeout(timeoutId);
        if (observer) observer.disconnect();
      };

      // è®¾ç½®è¶…æ—¶
      timeoutId = setTimeout(() => {
        cleanup();
        reject(new Error(\`ç­‰å¾…å…ƒç´ è¶…æ—¶: ${selector}\`));
      }, timeout);

      // ç›‘å¬ DOM å˜åŒ–
      observer = new MutationObserver(() => {
        const element = document.querySelector(selector);
        if (element) {
          cleanup();
          resolve(element);
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true
      });
    });
  }

  async waitForCondition(conditionFn, timeout = this.defaultTimeout, errorMessage = 'ç­‰å¾…æ¡ä»¶è¶…æ—¶') {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      const check = async () => {
        try {
          const result = await conditionFn();
          if (result) {
            resolve(result);
            return;
          }
        } catch (error) {
          // ç»§ç»­ç­‰å¾…
        }

        if (Date.now() - startTime >= timeout) {
          reject(new Error(errorMessage));
          return;
        }

        setTimeout(check, 100);
      };

      check();
    });
  }

  async waitForFunction(fn, timeout = this.defaultTimeout) {
    return this.waitForCondition(fn, timeout, 'ç­‰å¾…å‡½æ•°æ¡ä»¶è¶…æ—¶');
  }

  async waitForURL(urlPattern, timeout = this.defaultTimeout) {
    return this.waitForCondition(
      () => {
        if (typeof urlPattern === 'string') {
          return window.location.href.includes(urlPattern);
        }
        if (urlPattern instanceof RegExp) {
          return urlPattern.test(window.location.href);
        }
        return false;
      },
      timeout,
      \`ç­‰å¾…URLå˜åŒ–è¶…æ—¶: ${urlPattern}\`
    );
  }
}
```

### 6. æ–­è¨€é€‚é…å™¨

```javascript
class ExpectAdapter {
  constructor(target) {
    this.target = target;
    this.isNot = false;
  }

  get not() {
    const newExpect = new ExpectAdapter(this.target);
    newExpect.isNot = !this.isNot;
    return newExpect;
  }

  async toBeVisible() {
    const isVisible = await this.target.isVisible();
    const expected = !this.isNot;
    
    if (isVisible !== expected) {
      throw new Error(\`æœŸæœ›å…ƒç´ ${expected ? 'å¯è§' : 'ä¸å¯è§'}ï¼Œä½†å®é™…${isVisible ? 'å¯è§' : 'ä¸å¯è§'}\`);
    }
  }

  async toBeHidden() {
    const isVisible = await this.target.isVisible();
    const expected = this.isNot;
    
    if (isVisible !== expected) {
      throw new Error(\`æœŸæœ›å…ƒç´ ${expected ? 'å¯è§' : 'éšè—'}ï¼Œä½†å®é™…${isVisible ? 'å¯è§' : 'éšè—'}\`);
    }
  }

  async toBeEnabled() {
    const isEnabled = await this.target.isEnabled();
    const expected = !this.isNot;
    
    if (isEnabled !== expected) {
      throw new Error(\`æœŸæœ›å…ƒç´ ${expected ? 'å¯ç”¨' : 'ç¦ç”¨'}ï¼Œä½†å®é™…${isEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}\`);
    }
  }

  async toHaveText(expectedText) {
    const actualText = await this.target.textContent();
    const matches = actualText.includes(expectedText);
    const expected = !this.isNot;
    
    if (matches !== expected) {
      throw new Error(\`æœŸæœ›æ–‡æœ¬${expected ? 'åŒ…å«' : 'ä¸åŒ…å«'} "${expectedText}"ï¼Œä½†å®é™…æ–‡æœ¬ä¸º "${actualText}"\`);
    }
  }

  async toHaveValue(expectedValue) {
    const actualValue = await this.target.getAttribute('value') || '';
    const matches = actualValue === expectedValue;
    const expected = !this.isNot;
    
    if (matches !== expected) {
      throw new Error(\`æœŸæœ›å€¼${expected ? 'ä¸º' : 'ä¸ä¸º'} "${expectedValue}"ï¼Œä½†å®é™…å€¼ä¸º "${actualValue}"\`);
    }
  }
}

// å…¨å±€ expect å‡½æ•°
window.expect = function(target) {
  return new ExpectAdapter(target);
};
```

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### ç›´æ¥æ‰§è¡Œ Playwright è„šæœ¬
```javascript
// åˆå§‹åŒ–å¼•æ“
const engine = new PlaywrightExecutionEngine();

// åŠ è½½å¹¶æ‰§è¡Œ Playwright è„šæœ¬
const script = \`
import { test, expect } from '@playwright/test';

test('ç™»å½•æµ‹è¯•', async ({ page }) => {
  await page.goto('https://example.com/login');
  await page.fill('#username', 'testuser');
  await page.fill('#password', 'password123');
  await page.click('#login-button');
  await expect(page.locator('#welcome-message')).toBeVisible();
});
\`;

// è§£æå¹¶æ‰§è¡Œ
const parser = new PlaywrightScriptParser();
const testCases = parser.parse(script);

for (const testCase of testCases) {
  const result = await engine.execute(testCase);
  console.log(\`æµ‹è¯• "${testCase.name}" æ‰§è¡Œç»“æœ:`, result);
}
```

### API å…¼å®¹æ€§ä½¿ç”¨
```javascript
// å®Œå…¨å…¼å®¹ Playwright API è¯­æ³•
const page = new PageAdapter();

await page.goto('https://example.com');
await page.click('.button');
await page.fill('#input', 'Hello World');

const locator = page.locator('.result');
await expect(locator).toBeVisible();
await expect(locator).toHaveText('Success');
```

## ğŸ“‹ å®ç°è·¯çº¿å›¾

### Phase 1: æ ¸å¿ƒè¿è¡Œæ—¶ (1-2å‘¨)
- [ ] å®ç° Playwright è¿è¡Œæ—¶é€‚é…å™¨
- [ ] åˆ›å»ºæµ‹è¯•è¿è¡Œå™¨
- [ ] å®ç°åŸºç¡€çš„æ¨¡å—ç³»ç»Ÿå’Œ import è½¬æ¢
- [ ] åŸºç¡€é”™è¯¯å¤„ç†å’Œæ—¥å¿—

### Phase 2: å®šä½å™¨ç³»ç»Ÿ (2-3å‘¨)  
- [ ] å®ç°å®Œæ•´çš„ Locator ç±»
- [ ] æ·»åŠ ç°ä»£å®šä½å™¨ (getByRole, getByText ç­‰)
- [ ] å®ç°ç­‰å¾…æœºåˆ¶ (waitForSelector, waitForCondition)
- [ ] æ·»åŠ æ–­è¨€ç³»ç»Ÿ

### Phase 3: é«˜çº§åŠŸèƒ½ (3-4å‘¨)
- [ ] è¡¨å•æ§ä»¶æ“ä½œ (check, selectOption)
- [ ] é”®ç›˜å’Œé¼ æ ‡äº‹ä»¶
- [ ] é¡µé¢çŠ¶æ€ç­‰å¾…
- [ ] é«˜çº§å®šä½å™¨è¿‡æ»¤å™¨

### Phase 4: ç”Ÿäº§å°±ç»ª (2-3å‘¨)
- [ ] é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] å…¼å®¹æ€§æµ‹è¯•
- [ ] æ–‡æ¡£å’Œç¤ºä¾‹

è¿™ä¸ªè®¾è®¡ç¡®ä¿äº†ï¼š
1. **å®Œå…¨å…¼å®¹** - å¯ä»¥ç›´æ¥è¿è¡Œ Playwright å½•åˆ¶çš„è„šæœ¬
2. **æ¸è¿›å®ç°** - æŒ‰ä¼˜å…ˆçº§é€æ­¥å®ç°åŠŸèƒ½
3. **å¯æ‰©å±•æ€§** - æ¨¡å—åŒ–è®¾è®¡ä¾¿äºæ·»åŠ æ–°åŠŸèƒ½
4. **ç”Ÿäº§å°±ç»ª** - åŒ…å«é”™è¯¯å¤„ç†ã€æ—¥å¿—ã€æµ‹è¯•ç­‰