# Playwright ÊµèËßàÂô®ÊâßË°åÂºïÊìéÊû∂ÊûÑËÆæËÆ°

## üéØ È°πÁõÆÁõÆÊ†á
ÂàõÂª∫‰∏Ä‰∏™ËÉΩÂ§üÂú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠Áõ¥Êé•ËøêË°å Playwright ÂΩïÂà∂ËÑöÊú¨ÁöÑÊâßË°åÂºïÊìéÔºåÂÆåÂÖ®ÂÖºÂÆπ Playwright ËØ≠Ê≥ï„ÄÇ

## üèóÔ∏è Êï¥‰ΩìÊû∂ÊûÑ

### Ê†∏ÂøÉÊ®°ÂùóÂàíÂàÜ
```
playwright-execution-engine/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ runtime/             # ËøêË°åÊó∂ÁéØÂ¢É
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ playwright-runtime.js # Playwright ËøêË°åÊó∂ÈÄÇÈÖç
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-runner.js         # ÊµãËØïËøêË°åÂô®
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ module-loader.js       # Ê®°ÂùóÂä†ËΩΩÂô®
‚îÇ   ‚îú‚îÄ‚îÄ adapters/            # API ÈÄÇÈÖçÂ±Ç
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page-adapter.js     # Page API ÈÄÇÈÖç
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ locator-adapter.js  # Locator API ÈÄÇÈÖç
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ browser-adapter.js  # Browser API ÈÄÇÈÖç
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ expect-adapter.js   # Êñ≠Ë®Ä API ÈÄÇÈÖç
‚îÇ   ‚îú‚îÄ‚îÄ dom/                 # DOM Êìç‰ΩúÂ∞ÅË£Ö
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ element-finder.js   # ÂÖÉÁ¥†Êü•Êâæ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event-simulator.js  # ‰∫ã‰ª∂Ê®°Êãü
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wait-manager.js     # Á≠âÂæÖÊú∫Âà∂
‚îÇ   ‚îî‚îÄ‚îÄ utils/               # Â∑•ÂÖ∑ÂáΩÊï∞
‚îÇ       ‚îú‚îÄ‚îÄ logger.js           # Êó•ÂøóÁ≥ªÁªü
‚îÇ       ‚îú‚îÄ‚îÄ error-handler.js    # ÈîôËØØÂ§ÑÁêÜ
‚îÇ       ‚îî‚îÄ‚îÄ compatibility.js    # ÂÖºÂÆπÊÄßÊ£ÄÊü•
‚îú‚îÄ‚îÄ examples/                # Á§∫‰æãËÑöÊú¨
‚îú‚îÄ‚îÄ tests/                  # ÊµãËØïÁî®‰æã
‚îî‚îÄ‚îÄ dist/                   # ÊûÑÂª∫ËæìÂá∫
```

## üîß Ê†∏ÂøÉÁªÑ‰ª∂ËÆæËÆ°

### 1. Playwright ËøêË°åÊó∂ÈÄÇÈÖç (Playwright Runtime)

Áõ¥Êé•ÊõøÊç¢ Playwright ÁöÑÂØºÂÖ•Ê®°ÂùóÔºåËÆ©ËÑöÊú¨ÂèØ‰ª•ÂéüÊ†∑ËøêË°åÔºö

```javascript
// src/runtime/playwright-runtime.js
class PlaywrightRuntime {
  constructor() {
    this.setupGlobalEnvironment();
  }

  setupGlobalEnvironment() {
    // Ê®°Êãü @playwright/test Ê®°Âùó
    window.PlaywrightTest = {
      test: this.createTestFunction(),
      expect: this.createExpectFunction()
    };

    // ÂàõÂª∫Ê®°ÂùóÂä†ËΩΩÂô®
    this.setupModuleSystem();
  }

  createTestFunction() {
    return (name, testFn) => {
      return {
        name,
        fn: testFn,
        run: async () => {
          const page = new PageAdapter();
          const context = { page };
          
          try {
            await testFn(context);
            console.log(`‚úÖ ÊµãËØïÈÄöËøá: ${name}`);
            return { success: true };
          } catch (error) {
            console.error(`‚ùå ÊµãËØïÂ§±Ë¥•: ${name}`, error);
            return { success: false, error };
          }
        }
      };
    };
  }

  createExpectFunction() {
    return (target) => new ExpectAdapter(target);
  }

  // ËÆæÁΩÆÊ®°ÂùóÁ≥ªÁªüÔºåËÆ© import ËØ≠Âè•Ê≠£Â∏∏Â∑•‰Ωú
  setupModuleSystem() {
    // Êã¶Êà™ ES6 import
    if (typeof window.importShim === 'undefined') {
      window.importShim = {
        '@playwright/test': window.PlaywrightTest
      };
    }
  }

  // Áõ¥Êé•ÊâßË°å Playwright ËÑöÊú¨
  async executeScript(scriptContent) {
    // ËΩ¨Êç¢ import ËØ≠Âè•‰∏∫Êàë‰ª¨ÁöÑËøêË°åÊó∂
    const transformedScript = this.transformImports(scriptContent);
    
    // Âú®Ê≤ôÁÆ±ÁéØÂ¢É‰∏≠ÊâßË°å
    const testCases = await this.runInSandbox(transformedScript);
    
    // ÊâßË°åÊâÄÊúâÊµãËØï
    const results = [];
    for (const test of testCases) {
      const result = await test.run();
      results.push({ name: test.name, ...result });
    }
    
    return results;
  }

  transformImports(scriptContent) {
    // ÁÆÄÂçïÁöÑÂ≠óÁ¨¶‰∏≤ÊõøÊç¢ÔºåÂ∞Ü import ËΩ¨Êç¢‰∏∫Êàë‰ª¨ÁöÑËøêË°åÊó∂
    return scriptContent
      .replace(/import\s*{\s*test,?\s*expect\s*}\s*from\s*['"]@playwright\/test['"];?/g, 
               'const { test, expect } = window.PlaywrightTest;')
      .replace(/import\s*{\s*expect,?\s*test\s*}\s*from\s*['"]@playwright\/test['"];?/g, 
               'const { test, expect } = window.PlaywrightTest;');
  }

  async runInSandbox(scriptContent) {
    const testCases = [];
    
    // ÈáçÂÜô test ÂáΩÊï∞Êù•Êî∂ÈõÜÊµãËØïÁî®‰æã
    const originalTest = window.PlaywrightTest.test;
    window.PlaywrightTest.test = (name, fn) => {
      const testCase = originalTest(name, fn);
      testCases.push(testCase);
      return testCase;
    };

    // ÊâßË°åËÑöÊú¨
    const scriptFunction = new Function(scriptContent);
    scriptFunction();

    // ÊÅ¢Â§çÂéüÂßã test ÂáΩÊï∞
    window.PlaywrightTest.test = originalTest;

    return testCases;
  }
}
```

### 2. ÊµãËØïËøêË°åÂô® (Test Runner)

```javascript
// src/runtime/test-runner.js
class TestRunner {
  constructor() {
    this.runtime = new PlaywrightRuntime();
    this.logger = new Logger();
  }

  // ‰ªéÊñá‰ª∂Âä†ËΩΩÂπ∂ÊâßË°åËÑöÊú¨
  async loadAndRun(scriptPath) {
    try {
      const response = await fetch(scriptPath);
      const scriptContent = await response.text();
      return await this.runtime.executeScript(scriptContent);
    } catch (error) {
      this.logger.error('ËÑöÊú¨Âä†ËΩΩÂ§±Ë¥•:', error);
      throw error;
    }
  }

  // Áõ¥Êé•ÊâßË°åËÑöÊú¨Â≠óÁ¨¶‰∏≤
  async runScript(scriptContent) {
    return await this.runtime.executeScript(scriptContent);
  }

  // ÊâßË°åÂ§ö‰∏™ËÑöÊú¨Êñá‰ª∂
  async runScripts(scriptPaths) {
    const allResults = [];
    
    for (const path of scriptPaths) {
      this.logger.info(`ÊâßË°åËÑöÊú¨: ${path}`);
      const results = await this.loadAndRun(path);
      allResults.push({ script: path, results });
    }
    
    return allResults;
  }
}
```

### 3. Page API ÈÄÇÈÖçÂô®

```javascript
class PageAdapter {
  constructor() {
    this.waitManager = new WaitManager();
    this.eventSimulator = new EventSimulator();
    this.elementFinder = new ElementFinder();
  }

  // Ê†∏ÂøÉÂØºËà™ API
  async goto(url) {
    if (window.location.href !== url) {
      window.location.href = url;
      await this.waitForLoadState('domcontentloaded');
    }
  }

  url() {
    return window.location.href;
  }

  title() {
    return document.title;
  }

  // Ê†∏ÂøÉ‰∫§‰∫í API
  async click(selector, options = {}) {
    const element = await this.waitForSelector(selector);
    await this.scrollIntoViewIfNeeded(element);
    
    // Ëß¶ÂèëÂÆåÊï¥ÁöÑÁÇπÂáª‰∫ã‰ª∂Â∫èÂàó
    this.eventSimulator.simulateClick(element, options);
  }

  async fill(selector, value, options = {}) {
    const element = await this.waitForSelector(selector);
    await this.scrollIntoViewIfNeeded(element);
    
    // Ê∏ÖÁ©∫Âπ∂Â°´ÂÖÖ
    element.value = '';
    element.value = value;
    
    // Ëß¶ÂèëÁõ∏ÂÖ≥‰∫ã‰ª∂
    element.dispatchEvent(new Event('input', { bubbles: true }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
  }

  async press(selector, key) {
    const element = await this.waitForSelector(selector);
    element.focus();
    
    const keyEvent = new KeyboardEvent('keydown', {
      key: key,
      code: key,
      bubbles: true
    });
    
    element.dispatchEvent(keyEvent);
  }

  // Á≠âÂæÖÊú∫Âà∂
  async waitForSelector(selector, options = {}) {
    const timeout = options.timeout || 30000;
    return this.waitManager.waitForElement(selector, timeout);
  }

  async waitForTimeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async waitForLoadState(state = 'load') {
    return new Promise((resolve) => {
      if (state === 'load' && document.readyState === 'complete') {
        resolve();
      } else if (state === 'domcontentloaded' && document.readyState !== 'loading') {
        resolve();
      } else {
        const handler = () => {
          if ((state === 'load' && document.readyState === 'complete') ||
              (state === 'domcontentloaded' && document.readyState !== 'loading')) {
            resolve();
          }
        };
        document.addEventListener('readystatechange', handler, { once: true });
      }
    });
  }

  // Áé∞‰ª£ÂÆö‰ΩçÂô® API
  locator(selector) {
    return new LocatorAdapter(selector, this);
  }

  getByRole(role, options = {}) {
    const { name } = options;
    let selector = `[role="${role}"]`;
    
    if (name) {
      selector = `[role="${role}"][aria-label*="${name}"], [role="${role}"][aria-labelledby] *:contains("${name}")`;
    }
    
    return this.locator(selector);
  }

  getByText(text, options = {}) {
    const { exact = false } = options;
    const xpath = exact 
      ? `//\*[text()="${text}"]`
      : `//\*[contains(text(),"${text}")]`;
    
    return this.locator(\`xpath=${xpath}\`);
  }

  getByLabel(text) {
    const selector = \`label:contains("${text}") input, input[aria-labelledby]:has(~ *:contains("${text}"))\`;
    return this.locator(selector);
  }

  getByPlaceholder(text) {
    return this.locator(\`[placeholder*="${text}"]\`);
  }

  // È°µÈù¢ÂÜÖÂÆπËé∑Âèñ
  async content() {
    return document.documentElement.outerHTML;
  }

  async evaluate(fn, ...args) {
    return fn.apply(window, args);
  }

  // Ë°®ÂçïÊéß‰ª∂Êìç‰Ωú
  async check(selector) {
    const element = await this.waitForSelector(selector);
    if (element.type === 'checkbox' || element.type === 'radio') {
      element.checked = true;
      element.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  async uncheck(selector) {
    const element = await this.waitForSelector(selector);
    if (element.type === 'checkbox') {
      element.checked = false;
      element.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  async selectOption(selector, value) {
    const element = await this.waitForSelector(selector);
    if (element.tagName === 'SELECT') {
      element.value = value;
      element.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  // ËæÖÂä©ÊñπÊ≥ï
  async scrollIntoViewIfNeeded(element) {
    const rect = element.getBoundingClientRect();
    if (rect.bottom < 0 || rect.top > window.innerHeight) {
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      await this.waitForTimeout(100); // Á≠âÂæÖÊªöÂä®ÂÆåÊàê
    }
  }
}
```

### 4. Locator ÈÄÇÈÖçÂô®

```javascript
class LocatorAdapter {
  constructor(selector, page) {
    this.selector = selector;
    this.page = page;
    this.filters = [];
  }

  // ÈìæÂºèËøáÊª§Âô®
  filter(options) {
    const newLocator = new LocatorAdapter(this.selector, this.page);
    newLocator.filters = [...this.filters, options];
    return newLocator;
  }

  first() {
    return this.nth(0);
  }

  last() {
    return this.filter({ position: 'last' });
  }

  nth(n) {
    return this.filter({ position: n });
  }

  // Ê†∏ÂøÉÊìç‰ΩúÊñπÊ≥ï
  async click(options = {}) {
    const element = await this.getElement();
    return this.page.click(this.buildSelector(element), options);
  }

  async fill(value, options = {}) {
    const element = await this.getElement();
    return this.page.fill(this.buildSelector(element), value, options);
  }

  async press(key) {
    const element = await this.getElement();
    return this.page.press(this.buildSelector(element), key);
  }

  // Áä∂ÊÄÅÊ£ÄÊü•
  async isVisible() {
    try {
      const element = await this.getElement();
      return element.offsetParent !== null && 
             getComputedStyle(element).visibility !== 'hidden';
    } catch {
      return false;
    }
  }

  async isEnabled() {
    try {
      const element = await this.getElement();
      return !element.disabled;
    } catch {
      return false;
    }
  }

  async isChecked() {
    try {
      const element = await this.getElement();
      return element.checked || false;
    } catch {
      return false;
    }
  }

  // ÂÜÖÂÆπËé∑Âèñ
  async textContent() {
    const element = await this.getElement();
    return element.textContent;
  }

  async innerText() {
    const element = await this.getElement();
    return element.innerText;
  }

  async getAttribute(name) {
    const element = await this.getElement();
    return element.getAttribute(name);
  }

  // Á≠âÂæÖÊñπÊ≥ï
  async waitFor(options = {}) {
    const { state = 'visible', timeout = 30000 } = options;
    
    switch (state) {
      case 'visible':
        return this.waitForVisible(timeout);
      case 'hidden':
        return this.waitForHidden(timeout);
      case 'attached':
        return this.waitForAttached(timeout);
      case 'detached':
        return this.waitForDetached(timeout);
    }
  }

  async waitForVisible(timeout) {
    return this.page.waitManager.waitForCondition(
      () => this.isVisible(),
      timeout,
      \`ÂÖÉÁ¥† "${this.selector}" Á≠âÂæÖÂèØËßÅË∂ÖÊó∂\`
    );
  }

  // ÂÜÖÈÉ®ÊñπÊ≥ï
  async getElement() {
    const elements = document.querySelectorAll(this.selector);
    
    if (elements.length === 0) {
      throw new Error(\`Êâæ‰∏çÂà∞ÂÖÉÁ¥†: ${this.selector}\`);
    }

    // Â∫îÁî®ËøáÊª§Âô®
    let filteredElements = Array.from(elements);
    
    for (const filter of this.filters) {
      filteredElements = this.applyFilter(filteredElements, filter);
    }

    if (filteredElements.length === 0) {
      throw new Error(\`ËøáÊª§ÂêéÊâæ‰∏çÂà∞ÂÖÉÁ¥†: ${this.selector}\`);
    }

    return filteredElements[0];
  }

  applyFilter(elements, filter) {
    if (typeof filter.position === 'number') {
      return elements[filter.position] ? [elements[filter.position]] : [];
    }
    
    if (filter.position === 'last') {
      return elements.length > 0 ? [elements[elements.length - 1]] : [];
    }

    if (filter.hasText) {
      return elements.filter(el => 
        el.textContent.includes(filter.hasText)
      );
    }

    return elements;
  }

  buildSelector(element) {
    // Â¶ÇÊûúÂ∑≤ÁªèÊúâÂÖ∑‰ΩìÂÖÉÁ¥†ÔºåÊûÑÂª∫ÂîØ‰∏ÄÈÄâÊã©Âô®
    if (element.id) {
      return \`#${element.id}\`;
    }
    
    // ÊûÑÂª∫Ë∑ØÂæÑÈÄâÊã©Âô®
    const path = [];
    let current = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.className) {
        selector += '.' + current.className.split(' ').join('.');
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    return path.join(' > ');
  }
}
```

### 5. Á≠âÂæÖÁÆ°ÁêÜÂô®

```javascript
class WaitManager {
  constructor() {
    this.defaultTimeout = 30000;
  }

  async waitForElement(selector, timeout = this.defaultTimeout) {
    return new Promise((resolve, reject) => {
      // Á´ãÂç≥Ê£ÄÊü•
      const existing = document.querySelector(selector);
      if (existing) return resolve(existing);

      let timeoutId;
      let observer;

      const cleanup = () => {
        if (timeoutId) clearTimeout(timeoutId);
        if (observer) observer.disconnect();
      };

      // ËÆæÁΩÆË∂ÖÊó∂
      timeoutId = setTimeout(() => {
        cleanup();
        reject(new Error(\`Á≠âÂæÖÂÖÉÁ¥†Ë∂ÖÊó∂: ${selector}\`));
      }, timeout);

      // ÁõëÂê¨ DOM ÂèòÂåñ
      observer = new MutationObserver(() => {
        const element = document.querySelector(selector);
        if (element) {
          cleanup();
          resolve(element);
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true
      });
    });
  }

  async waitForCondition(conditionFn, timeout = this.defaultTimeout, errorMessage = 'Á≠âÂæÖÊù°‰ª∂Ë∂ÖÊó∂') {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      const check = async () => {
        try {
          const result = await conditionFn();
          if (result) {
            resolve(result);
            return;
          }
        } catch (error) {
          // ÁªßÁª≠Á≠âÂæÖ
        }

        if (Date.now() - startTime >= timeout) {
          reject(new Error(errorMessage));
          return;
        }

        setTimeout(check, 100);
      };

      check();
    });
  }

  async waitForFunction(fn, timeout = this.defaultTimeout) {
    return this.waitForCondition(fn, timeout, 'Á≠âÂæÖÂáΩÊï∞Êù°‰ª∂Ë∂ÖÊó∂');
  }

  async waitForURL(urlPattern, timeout = this.defaultTimeout) {
    return this.waitForCondition(
      () => {
        if (typeof urlPattern === 'string') {
          return window.location.href.includes(urlPattern);
        }
        if (urlPattern instanceof RegExp) {
          return urlPattern.test(window.location.href);
        }
        return false;
      },
      timeout,
      \`Á≠âÂæÖURLÂèòÂåñË∂ÖÊó∂: ${urlPattern}\`
    );
  }
}
```

### 6. Êñ≠Ë®ÄÈÄÇÈÖçÂô®

```javascript
class ExpectAdapter {
  constructor(target) {
    this.target = target;
    this.isNot = false;
  }

  get not() {
    const newExpect = new ExpectAdapter(this.target);
    newExpect.isNot = !this.isNot;
    return newExpect;
  }

  async toBeVisible() {
    const isVisible = await this.target.isVisible();
    const expected = !this.isNot;
    
    if (isVisible !== expected) {
      throw new Error(\`ÊúüÊúõÂÖÉÁ¥†${expected ? 'ÂèØËßÅ' : '‰∏çÂèØËßÅ'}Ôºå‰ΩÜÂÆûÈôÖ${isVisible ? 'ÂèØËßÅ' : '‰∏çÂèØËßÅ'}\`);
    }
  }

  async toBeHidden() {
    const isVisible = await this.target.isVisible();
    const expected = this.isNot;
    
    if (isVisible !== expected) {
      throw new Error(\`ÊúüÊúõÂÖÉÁ¥†${expected ? 'ÂèØËßÅ' : 'ÈöêËóè'}Ôºå‰ΩÜÂÆûÈôÖ${isVisible ? 'ÂèØËßÅ' : 'ÈöêËóè'}\`);
    }
  }

  async toBeEnabled() {
    const isEnabled = await this.target.isEnabled();
    const expected = !this.isNot;
    
    if (isEnabled !== expected) {
      throw new Error(\`ÊúüÊúõÂÖÉÁ¥†${expected ? 'ÂêØÁî®' : 'Á¶ÅÁî®'}Ôºå‰ΩÜÂÆûÈôÖ${isEnabled ? 'ÂêØÁî®' : 'Á¶ÅÁî®'}\`);
    }
  }

  async toHaveText(expectedText) {
    const actualText = await this.target.textContent();
    const matches = actualText.includes(expectedText);
    const expected = !this.isNot;
    
    if (matches !== expected) {
      throw new Error(\`ÊúüÊúõÊñáÊú¨${expected ? 'ÂåÖÂê´' : '‰∏çÂåÖÂê´'} "${expectedText}"Ôºå‰ΩÜÂÆûÈôÖÊñáÊú¨‰∏∫ "${actualText}"\`);
    }
  }

  async toHaveValue(expectedValue) {
    const actualValue = await this.target.getAttribute('value') || '';
    const matches = actualValue === expectedValue;
    const expected = !this.isNot;
    
    if (matches !== expected) {
      throw new Error(\`ÊúüÊúõÂÄº${expected ? '‰∏∫' : '‰∏ç‰∏∫'} "${expectedValue}"Ôºå‰ΩÜÂÆûÈôÖÂÄº‰∏∫ "${actualValue}"\`);
    }
  }
}

// ÂÖ®Â±Ä expect ÂáΩÊï∞
window.expect = function(target) {
  return new ExpectAdapter(target);
};
```

## üöÄ ‰ΩøÁî®Á§∫‰æã

### Áõ¥Êé•ÊâßË°å Playwright ËÑöÊú¨
```javascript
// ÂàùÂßãÂåñÂºïÊìé
const engine = new PlaywrightExecutionEngine();

// Âä†ËΩΩÂπ∂ÊâßË°å Playwright ËÑöÊú¨
const script = \`
import { test, expect } from '@playwright/test';

test('ÁôªÂΩïÊµãËØï', async ({ page }) => {
  await page.goto('https://example.com/login');
  await page.fill('#username', 'testuser');
  await page.fill('#password', 'password123');
  await page.click('#login-button');
  await expect(page.locator('#welcome-message')).toBeVisible();
});
\`;

// Ëß£ÊûêÂπ∂ÊâßË°å
const parser = new PlaywrightScriptParser();
const testCases = parser.parse(script);

for (const testCase of testCases) {
  const result = await engine.execute(testCase);
  console.log(\`ÊµãËØï "${testCase.name}" ÊâßË°åÁªìÊûú:`, result);
}
```

### API ÂÖºÂÆπÊÄß‰ΩøÁî®
```javascript
// ÂÆåÂÖ®ÂÖºÂÆπ Playwright API ËØ≠Ê≥ï
const page = new PageAdapter();

await page.goto('https://example.com');
await page.click('.button');
await page.fill('#input', 'Hello World');

const locator = page.locator('.result');
await expect(locator).toBeVisible();
await expect(locator).toHaveText('Success');
```

## üìã ÂÆûÁé∞Ë∑ØÁ∫øÂõæ

### Phase 1: Ê†∏ÂøÉËøêË°åÊó∂ (1-2Âë®)
- [ ] ÂÆûÁé∞ Playwright ËøêË°åÊó∂ÈÄÇÈÖçÂô®
- [ ] ÂàõÂª∫ÊµãËØïËøêË°åÂô®
- [ ] ÂÆûÁé∞Âü∫Á°ÄÁöÑÊ®°ÂùóÁ≥ªÁªüÂíå import ËΩ¨Êç¢
- [ ] Âü∫Á°ÄÈîôËØØÂ§ÑÁêÜÂíåÊó•Âøó

### Phase 2: ÂÆö‰ΩçÂô®Á≥ªÁªü (2-3Âë®)  
- [ ] ÂÆûÁé∞ÂÆåÊï¥ÁöÑ Locator Á±ª
- [ ] Ê∑ªÂä†Áé∞‰ª£ÂÆö‰ΩçÂô® (getByRole, getByText Á≠â)
- [ ] ÂÆûÁé∞Á≠âÂæÖÊú∫Âà∂ (waitForSelector, waitForCondition)
- [ ] Ê∑ªÂä†Êñ≠Ë®ÄÁ≥ªÁªü

### Phase 3: È´òÁ∫ßÂäüËÉΩ (3-4Âë®)
- [ ] Ë°®ÂçïÊéß‰ª∂Êìç‰Ωú (check, selectOption)
- [ ] ÈîÆÁõòÂíåÈº†Ê†á‰∫ã‰ª∂
- [ ] È°µÈù¢Áä∂ÊÄÅÁ≠âÂæÖ
- [ ] È´òÁ∫ßÂÆö‰ΩçÂô®ËøáÊª§Âô®

### Phase 4: Áîü‰∫ßÂ∞±Áª™ (2-3Âë®)
- [ ] ÈîôËØØÂ§ÑÁêÜÂíåÈáçËØïÊú∫Âà∂
- [ ] ÊÄßËÉΩ‰ºòÂåñ
- [ ] ÂÖºÂÆπÊÄßÊµãËØï
- [ ] ÊñáÊ°£ÂíåÁ§∫‰æã

Ëøô‰∏™ËÆæËÆ°Á°Æ‰øù‰∫ÜÔºö
1. **ÂÆåÂÖ®ÂÖºÂÆπ** - ÂèØ‰ª•Áõ¥Êé•ËøêË°å Playwright ÂΩïÂà∂ÁöÑËÑöÊú¨
2. **Ê∏êËøõÂÆûÁé∞** - Êåâ‰ºòÂÖàÁ∫ßÈÄêÊ≠•ÂÆûÁé∞ÂäüËÉΩ
3. **ÂèØÊâ©Â±ïÊÄß** - Ê®°ÂùóÂåñËÆæËÆ°‰æø‰∫éÊ∑ªÂä†Êñ∞ÂäüËÉΩ
4. **Áîü‰∫ßÂ∞±Áª™** - ÂåÖÂê´ÈîôËØØÂ§ÑÁêÜ„ÄÅÊó•Âøó„ÄÅÊµãËØïÁ≠â